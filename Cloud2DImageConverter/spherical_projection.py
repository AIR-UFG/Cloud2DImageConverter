# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_spherical_projections.ipynb.

# %% auto 0
__all__ = ['color_map', 'spherical_projection_2', 'create_ImageMatrix', 'colored_matrix_with_label']

# %% ../nbs/01_spherical_projections.ipynb 3
from . import data

# %% ../nbs/01_spherical_projections.ipynb 4
import matplotlib.pyplot as plt
import numpy as np

# %% ../nbs/01_spherical_projections.ipynb 6
color_map = dict(data.color_map)

# %% ../nbs/01_spherical_projections.ipynb 7
'''
- Para a projeção esférica são lidos as coordenadas x,y,z de cada ponto
- R é a distância do laser até a origem (LiDAR)
- desvio_eixoY é o valor no plano xy e o ângulo com range de [FOV_UP, FOV_DOWN] para max/min
- desvio_eixoX é o valor no plano xz com range de [-pi,pi] por causa da função arctan2
- É necessário normalizar os desvios para pegar os pontos na distorção para 2D
- Como o modelo do LiDAR utilizado é o Velodyne HDL 64-E, a imagem deve ser 64x1024
- Retorna o ponto (normal_Y,normal_X, intensidade) da projeção
'''

def spherical_projection_2(point_cloud):
    x_coord = point_cloud[:, 0]
    y_coord = point_cloud[:, 1]
    z_coord = point_cloud[:, 2]

    R = np.sqrt(x_coord**2 + y_coord**2 + z_coord**2)

    desvio_eixoY = np.arcsin(z_coord/R)
    desvio_eixoX = -np.arctan2(y_coord, x_coord)

    FOV_UP = np.max(desvio_eixoY)
    FOV_DOWN = np.min(desvio_eixoY)
    FOV = FOV_UP + abs(FOV_DOWN)

    normal_Y = 1.0 - ((desvio_eixoY + abs(FOV_DOWN))/FOV)
    normal_X = 0.5 * ((desvio_eixoX/np.pi) + 1)

    return normal_Y*64, normal_X*1024, point_cloud[:, 3], point_cloud[:, 4]

# %% ../nbs/01_spherical_projections.ipynb 8
'''
- A imagem é formada no plano zy
- É necessário truncar os valores para servirem como índice na matriz
- Retorna a intensidade de cada ponto para formar a imagem
'''
def create_ImageMatrix(normal_Y, normal_X, intensity, label):
    truncated_Y = np.minimum(63, np.round(normal_Y))
    index_Y = np.maximum(0, truncated_Y).astype(int)
    
    truncated_X = np.minimum(1023, np.round(normal_X))
    index_X = np.maximum(0, truncated_X).astype(int)
    
    image_matrix_no_label = np.zeros((64, 1024))
    image_matrix_with_label = np.zeros((64, 1024))
    
    for x, y, i in zip(index_X, index_Y, intensity):
        image_matrix_no_label[y, x] = i
    
    for x, y, i in zip(index_X, index_Y, label):
        image_matrix_with_label[y, x] = i
        
    return image_matrix_no_label, image_matrix_with_label

# %% ../nbs/01_spherical_projections.ipynb 9
'''
- Substitui as keys da matriz de label pela respectiva cor do dicionário color_map
- Retorna a matriz de label no formato (64, 1024, 3)
'''
def colored_matrix_with_label(image_matrix_with_label):
    
    colored_matrix =  np.empty(image_matrix_with_label.shape + (3,), dtype=np.uint8)
    
    for key, value in color_map.items():
        indices = np.where(image_matrix_with_label == key)
        colored_matrix[indices] = value
    
    image_matrix_with_label = colored_matrix

    return image_matrix_with_label
