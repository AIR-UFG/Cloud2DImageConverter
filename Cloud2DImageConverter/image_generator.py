# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/02_image_generator.ipynb.

# %% auto 0
__all__ = ['FOV_UP', 'FOV_DOWN', 'WIDTH', 'HEIGHT', 'FOLDER_PATH', 'VELODYNE_PATH', 'LABEL_PATH', 'RESULTS_FOLDER', 'BATCH_SIZE',
           'MAX_LEN', 'label_list', 'define_range', 'do_projection', 'save_image', 'create_images']

# %% ../nbs/02_image_generator.ipynb 2
from . import spherical_projection as sp
from . import data
from matplotlib import pyplot as plt
from tqdm import tqdm
from PIL import Image
import numpy as np
import pickle 
import shutil
import time
import os

# %% ../nbs/02_image_generator.ipynb 4
FOV_UP = 3.0
FOV_DOWN = -25.0
WIDTH = 1024
HEIGHT = 64

# %% ../nbs/02_image_generator.ipynb 6
FOLDER_PATH = "../point_clouds/semantic_kitti/"
VELODYNE_PATH = FOLDER_PATH+"velodyne"
LABEL_PATH = FOLDER_PATH+"labels"
RESULTS_FOLDER =  "../results/"

BATCH_SIZE = 500
MAX_LEN = len(os.listdir(VELODYNE_PATH))

if BATCH_SIZE > MAX_LEN: 
    BATCH_SIZE = MAX_LEN-1

# %% ../nbs/02_image_generator.ipynb 7
if os.path.exists(RESULTS_FOLDER):
    shutil.rmtree(RESULTS_FOLDER)
    
os.makedirs(RESULTS_FOLDER)
os.makedirs(RESULTS_FOLDER+"/projections")
os.makedirs(RESULTS_FOLDER+"/labels")

# %% ../nbs/02_image_generator.ipynb 8
def define_range(batch, batch_size, max_len):
    start = batch - batch_size
    end = batch
    if (max_len - batch) < batch_size:
        end = max_len
    return start, end

# %% ../nbs/02_image_generator.ipynb 9
def do_projection(point_cloud):
    projection_dict = {"reflectance": [],"label": [], "depth": []}
    for points in point_cloud:
        reflectance, depth, mask = sp.spherical_projection(points, FOV_UP, FOV_DOWN, WIDTH, HEIGHT)
        projection_dict["reflectance"].append(reflectance)
        projection_dict["label"].append(mask)
        projection_dict["depth"].append(depth)
    return projection_dict

# %% ../nbs/02_image_generator.ipynb 10
def save_image(matrix, save_path):
    img = Image.fromarray(matrix)
    final_path = os.path.join(RESULTS_FOLDER+save_path)
    file_number = len(os.listdir(final_path)) + 1
    file_name = f"{final_path}/{file_number:06d}.png"
    img.save(file_name)

def create_images(projection_dict):
    # Itera sobre cada posição do dicionário agrupando junto as matrizes de mesmo indice
    for zip_dict in zip(projection_dict["reflectance"], projection_dict["label"], projection_dict["depth"]):
        # Alterna entre as chaves e os indices respectivos a cada chave
        aux_dict = {}
        for index, key in enumerate(projection_dict.keys()):
            matrix = zip_dict[index]
            if key != "label":
                norm_matrix = ((matrix - matrix.min()) / (matrix.max() - matrix.min())) * 255
                matrix = norm_matrix.astype(np.uint8)
            else:
                matrix = sp.colored_matrix_with_label(matrix)
            aux_dict[key] = matrix
        black_matrix = np.zeros((64, 1024), dtype=np.uint8)
        aux_dict["final_matrix"] = np.dstack((np.array(aux_dict["reflectance"]), np.array(aux_dict["depth"]), black_matrix))
        save_image(aux_dict["final_matrix"], "/projections")
        save_image(aux_dict["label"], "/labels")

# %% ../nbs/02_image_generator.ipynb 11
label_list = None
for batch in tqdm(range(BATCH_SIZE, MAX_LEN, BATCH_SIZE), desc="Batch:"):
    # Define o intervalo de carregamento dos dados
    start, end = define_range(batch, BATCH_SIZE, MAX_LEN)
    # Define as listas contendo os nomes dos arquivos
    velodyne_list = sorted(os.listdir(VELODYNE_PATH))[start:end]
    if LABEL_PATH != None:
        label_list = sorted(os.listdir(LABEL_PATH))[start:end]
    # Carrega os dados 
    point_cloud = data.load_data(VELODYNE_PATH, velodyne_list, LABEL_PATH, label_list)
    # Realiza a projeção esférica
    projection_dict = do_projection(point_cloud)
    # Cria e salva as imagens
    create_images(projection_dict)
